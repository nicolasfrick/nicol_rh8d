
atxmega_qenc.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00000cd8  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         00000036  00802000  00000cd8  00000d6c  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000034  00802036  00802036  00000da2  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  00000da2  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 00000040  00000000  00000000  00000dd4  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 000001b0  00000000  00000000  00000e14  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   00005777  00000000  00000000  00000fc4  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 00002ad9  00000000  00000000  0000673b  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   00001b6e  00000000  00000000  00009214  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  00000b18  00000000  00000000  0000ad84  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    0002bf7f  00000000  00000000  0000b89c  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    00001897  00000000  00000000  0003781b  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 00000190  00000000  00000000  000390b2  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_macro  00000bd5  00000000  00000000  00039242  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
   0:	fd c0       	rjmp	.+506    	; 0x1fc <__ctors_end>
   2:	00 00       	nop
   4:	16 c1       	rjmp	.+556    	; 0x232 <__bad_interrupt>
   6:	00 00       	nop
   8:	14 c1       	rjmp	.+552    	; 0x232 <__bad_interrupt>
   a:	00 00       	nop
   c:	12 c1       	rjmp	.+548    	; 0x232 <__bad_interrupt>
   e:	00 00       	nop
  10:	10 c1       	rjmp	.+544    	; 0x232 <__bad_interrupt>
  12:	00 00       	nop
  14:	0e c1       	rjmp	.+540    	; 0x232 <__bad_interrupt>
  16:	00 00       	nop
  18:	0c c1       	rjmp	.+536    	; 0x232 <__bad_interrupt>
  1a:	00 00       	nop
  1c:	0a c1       	rjmp	.+532    	; 0x232 <__bad_interrupt>
  1e:	00 00       	nop
  20:	08 c1       	rjmp	.+528    	; 0x232 <__bad_interrupt>
  22:	00 00       	nop
  24:	06 c1       	rjmp	.+524    	; 0x232 <__bad_interrupt>
  26:	00 00       	nop
  28:	04 c1       	rjmp	.+520    	; 0x232 <__bad_interrupt>
  2a:	00 00       	nop
  2c:	02 c1       	rjmp	.+516    	; 0x232 <__bad_interrupt>
  2e:	00 00       	nop
  30:	00 c1       	rjmp	.+512    	; 0x232 <__bad_interrupt>
  32:	00 00       	nop
  34:	fe c0       	rjmp	.+508    	; 0x232 <__bad_interrupt>
  36:	00 00       	nop
  38:	fd c0       	rjmp	.+506    	; 0x234 <__vector_14>
  3a:	00 00       	nop
  3c:	24 c1       	rjmp	.+584    	; 0x286 <__vector_15>
  3e:	00 00       	nop
  40:	4b c1       	rjmp	.+662    	; 0x2d8 <__vector_16>
  42:	00 00       	nop
  44:	72 c1       	rjmp	.+740    	; 0x32a <__vector_17>
  46:	00 00       	nop
  48:	99 c1       	rjmp	.+818    	; 0x37c <__vector_18>
  4a:	00 00       	nop
  4c:	c0 c1       	rjmp	.+896    	; 0x3ce <__vector_19>
  4e:	00 00       	nop
  50:	e7 c1       	rjmp	.+974    	; 0x420 <__vector_20>
  52:	00 00       	nop
  54:	0e c2       	rjmp	.+1052   	; 0x472 <__vector_21>
  56:	00 00       	nop
  58:	35 c2       	rjmp	.+1130   	; 0x4c4 <__vector_22>
  5a:	00 00       	nop
  5c:	5c c2       	rjmp	.+1208   	; 0x516 <__vector_23>
  5e:	00 00       	nop
  60:	e8 c0       	rjmp	.+464    	; 0x232 <__bad_interrupt>
  62:	00 00       	nop
  64:	e6 c0       	rjmp	.+460    	; 0x232 <__bad_interrupt>
  66:	00 00       	nop
  68:	e4 c0       	rjmp	.+456    	; 0x232 <__bad_interrupt>
  6a:	00 00       	nop
  6c:	e2 c0       	rjmp	.+452    	; 0x232 <__bad_interrupt>
  6e:	00 00       	nop
  70:	e0 c0       	rjmp	.+448    	; 0x232 <__bad_interrupt>
  72:	00 00       	nop
  74:	de c0       	rjmp	.+444    	; 0x232 <__bad_interrupt>
  76:	00 00       	nop
  78:	dc c0       	rjmp	.+440    	; 0x232 <__bad_interrupt>
  7a:	00 00       	nop
  7c:	da c0       	rjmp	.+436    	; 0x232 <__bad_interrupt>
  7e:	00 00       	nop
  80:	d8 c0       	rjmp	.+432    	; 0x232 <__bad_interrupt>
  82:	00 00       	nop
  84:	d6 c0       	rjmp	.+428    	; 0x232 <__bad_interrupt>
  86:	00 00       	nop
  88:	d4 c0       	rjmp	.+424    	; 0x232 <__bad_interrupt>
  8a:	00 00       	nop
  8c:	d2 c0       	rjmp	.+420    	; 0x232 <__bad_interrupt>
  8e:	00 00       	nop
  90:	d0 c0       	rjmp	.+416    	; 0x232 <__bad_interrupt>
  92:	00 00       	nop
  94:	ce c0       	rjmp	.+412    	; 0x232 <__bad_interrupt>
  96:	00 00       	nop
  98:	cc c0       	rjmp	.+408    	; 0x232 <__bad_interrupt>
  9a:	00 00       	nop
  9c:	ca c0       	rjmp	.+404    	; 0x232 <__bad_interrupt>
  9e:	00 00       	nop
  a0:	c8 c0       	rjmp	.+400    	; 0x232 <__bad_interrupt>
  a2:	00 00       	nop
  a4:	c6 c0       	rjmp	.+396    	; 0x232 <__bad_interrupt>
  a6:	00 00       	nop
  a8:	c4 c0       	rjmp	.+392    	; 0x232 <__bad_interrupt>
  aa:	00 00       	nop
  ac:	c2 c0       	rjmp	.+388    	; 0x232 <__bad_interrupt>
  ae:	00 00       	nop
  b0:	c0 c0       	rjmp	.+384    	; 0x232 <__bad_interrupt>
  b2:	00 00       	nop
  b4:	be c0       	rjmp	.+380    	; 0x232 <__bad_interrupt>
  b6:	00 00       	nop
  b8:	bc c0       	rjmp	.+376    	; 0x232 <__bad_interrupt>
  ba:	00 00       	nop
  bc:	ef c3       	rjmp	.+2014   	; 0x89c <__vector_47>
  be:	00 00       	nop
  c0:	16 c4       	rjmp	.+2092   	; 0x8ee <__vector_48>
  c2:	00 00       	nop
  c4:	3d c4       	rjmp	.+2170   	; 0x940 <__vector_49>
  c6:	00 00       	nop
  c8:	64 c4       	rjmp	.+2248   	; 0x992 <__vector_50>
  ca:	00 00       	nop
  cc:	8b c4       	rjmp	.+2326   	; 0x9e4 <__vector_51>
  ce:	00 00       	nop
  d0:	b2 c4       	rjmp	.+2404   	; 0xa36 <__vector_52>
  d2:	00 00       	nop
  d4:	ae c0       	rjmp	.+348    	; 0x232 <__bad_interrupt>
  d6:	00 00       	nop
  d8:	ac c0       	rjmp	.+344    	; 0x232 <__bad_interrupt>
  da:	00 00       	nop
  dc:	aa c0       	rjmp	.+340    	; 0x232 <__bad_interrupt>
  de:	00 00       	nop
  e0:	a8 c0       	rjmp	.+336    	; 0x232 <__bad_interrupt>
  e2:	00 00       	nop
  e4:	a6 c0       	rjmp	.+332    	; 0x232 <__bad_interrupt>
  e6:	00 00       	nop
  e8:	b1 c5       	rjmp	.+2914   	; 0xc4c <__vector_58>
  ea:	00 00       	nop
  ec:	a2 c0       	rjmp	.+324    	; 0x232 <__bad_interrupt>
  ee:	00 00       	nop
  f0:	a0 c0       	rjmp	.+320    	; 0x232 <__bad_interrupt>
  f2:	00 00       	nop
  f4:	9e c0       	rjmp	.+316    	; 0x232 <__bad_interrupt>
  f6:	00 00       	nop
  f8:	9c c0       	rjmp	.+312    	; 0x232 <__bad_interrupt>
  fa:	00 00       	nop
  fc:	9a c0       	rjmp	.+308    	; 0x232 <__bad_interrupt>
  fe:	00 00       	nop
 100:	98 c0       	rjmp	.+304    	; 0x232 <__bad_interrupt>
 102:	00 00       	nop
 104:	96 c0       	rjmp	.+300    	; 0x232 <__bad_interrupt>
 106:	00 00       	nop
 108:	94 c0       	rjmp	.+296    	; 0x232 <__bad_interrupt>
 10a:	00 00       	nop
 10c:	92 c0       	rjmp	.+292    	; 0x232 <__bad_interrupt>
 10e:	00 00       	nop
 110:	90 c0       	rjmp	.+288    	; 0x232 <__bad_interrupt>
 112:	00 00       	nop
 114:	8e c0       	rjmp	.+284    	; 0x232 <__bad_interrupt>
 116:	00 00       	nop
 118:	8c c0       	rjmp	.+280    	; 0x232 <__bad_interrupt>
 11a:	00 00       	nop
 11c:	8a c0       	rjmp	.+276    	; 0x232 <__bad_interrupt>
 11e:	00 00       	nop
 120:	88 c0       	rjmp	.+272    	; 0x232 <__bad_interrupt>
 122:	00 00       	nop
 124:	86 c0       	rjmp	.+268    	; 0x232 <__bad_interrupt>
 126:	00 00       	nop
 128:	84 c0       	rjmp	.+264    	; 0x232 <__bad_interrupt>
 12a:	00 00       	nop
 12c:	82 c0       	rjmp	.+260    	; 0x232 <__bad_interrupt>
 12e:	00 00       	nop
 130:	80 c0       	rjmp	.+256    	; 0x232 <__bad_interrupt>
 132:	00 00       	nop
 134:	19 c2       	rjmp	.+1074   	; 0x568 <__vector_77>
 136:	00 00       	nop
 138:	40 c2       	rjmp	.+1152   	; 0x5ba <__vector_78>
 13a:	00 00       	nop
 13c:	67 c2       	rjmp	.+1230   	; 0x60c <__vector_79>
 13e:	00 00       	nop
 140:	8e c2       	rjmp	.+1308   	; 0x65e <__vector_80>
 142:	00 00       	nop
 144:	b5 c2       	rjmp	.+1386   	; 0x6b0 <__vector_81>
 146:	00 00       	nop
 148:	dc c2       	rjmp	.+1464   	; 0x702 <__vector_82>
 14a:	00 00       	nop
 14c:	03 c3       	rjmp	.+1542   	; 0x754 <__vector_83>
 14e:	00 00       	nop
 150:	2a c3       	rjmp	.+1620   	; 0x7a6 <__vector_84>
 152:	00 00       	nop
 154:	51 c3       	rjmp	.+1698   	; 0x7f8 <__vector_85>
 156:	00 00       	nop
 158:	78 c3       	rjmp	.+1776   	; 0x84a <__vector_86>
 15a:	00 00       	nop
 15c:	6a c0       	rjmp	.+212    	; 0x232 <__bad_interrupt>
 15e:	00 00       	nop
 160:	68 c0       	rjmp	.+208    	; 0x232 <__bad_interrupt>
 162:	00 00       	nop
 164:	66 c0       	rjmp	.+204    	; 0x232 <__bad_interrupt>
 166:	00 00       	nop
 168:	64 c0       	rjmp	.+200    	; 0x232 <__bad_interrupt>
 16a:	00 00       	nop
 16c:	62 c0       	rjmp	.+196    	; 0x232 <__bad_interrupt>
 16e:	00 00       	nop
 170:	60 c0       	rjmp	.+192    	; 0x232 <__bad_interrupt>
 172:	00 00       	nop
 174:	5e c0       	rjmp	.+188    	; 0x232 <__bad_interrupt>
 176:	00 00       	nop
 178:	5c c0       	rjmp	.+184    	; 0x232 <__bad_interrupt>
 17a:	00 00       	nop
 17c:	5a c0       	rjmp	.+180    	; 0x232 <__bad_interrupt>
 17e:	00 00       	nop
 180:	58 c0       	rjmp	.+176    	; 0x232 <__bad_interrupt>
 182:	00 00       	nop
 184:	56 c0       	rjmp	.+172    	; 0x232 <__bad_interrupt>
 186:	00 00       	nop
 188:	54 c0       	rjmp	.+168    	; 0x232 <__bad_interrupt>
 18a:	00 00       	nop
 18c:	52 c0       	rjmp	.+164    	; 0x232 <__bad_interrupt>
 18e:	00 00       	nop
 190:	50 c0       	rjmp	.+160    	; 0x232 <__bad_interrupt>
 192:	00 00       	nop
 194:	4e c0       	rjmp	.+156    	; 0x232 <__bad_interrupt>
 196:	00 00       	nop
 198:	4c c0       	rjmp	.+152    	; 0x232 <__bad_interrupt>
 19a:	00 00       	nop
 19c:	4a c0       	rjmp	.+148    	; 0x232 <__bad_interrupt>
 19e:	00 00       	nop
 1a0:	48 c0       	rjmp	.+144    	; 0x232 <__bad_interrupt>
 1a2:	00 00       	nop
 1a4:	46 c0       	rjmp	.+140    	; 0x232 <__bad_interrupt>
 1a6:	00 00       	nop
 1a8:	44 c0       	rjmp	.+136    	; 0x232 <__bad_interrupt>
 1aa:	00 00       	nop
 1ac:	42 c0       	rjmp	.+132    	; 0x232 <__bad_interrupt>
 1ae:	00 00       	nop
 1b0:	40 c0       	rjmp	.+128    	; 0x232 <__bad_interrupt>
 1b2:	00 00       	nop
 1b4:	3e c0       	rjmp	.+124    	; 0x232 <__bad_interrupt>
 1b6:	00 00       	nop
 1b8:	3c c0       	rjmp	.+120    	; 0x232 <__bad_interrupt>
 1ba:	00 00       	nop
 1bc:	3a c0       	rjmp	.+116    	; 0x232 <__bad_interrupt>
 1be:	00 00       	nop
 1c0:	38 c0       	rjmp	.+112    	; 0x232 <__bad_interrupt>
 1c2:	00 00       	nop
 1c4:	36 c0       	rjmp	.+108    	; 0x232 <__bad_interrupt>
 1c6:	00 00       	nop
 1c8:	34 c0       	rjmp	.+104    	; 0x232 <__bad_interrupt>
 1ca:	00 00       	nop
 1cc:	32 c0       	rjmp	.+100    	; 0x232 <__bad_interrupt>
 1ce:	00 00       	nop
 1d0:	30 c0       	rjmp	.+96     	; 0x232 <__bad_interrupt>
 1d2:	00 00       	nop
 1d4:	2e c0       	rjmp	.+92     	; 0x232 <__bad_interrupt>
 1d6:	00 00       	nop
 1d8:	2c c0       	rjmp	.+88     	; 0x232 <__bad_interrupt>
 1da:	00 00       	nop
 1dc:	2a c0       	rjmp	.+84     	; 0x232 <__bad_interrupt>
 1de:	00 00       	nop
 1e0:	28 c0       	rjmp	.+80     	; 0x232 <__bad_interrupt>
 1e2:	00 00       	nop
 1e4:	26 c0       	rjmp	.+76     	; 0x232 <__bad_interrupt>
 1e6:	00 00       	nop
 1e8:	24 c0       	rjmp	.+72     	; 0x232 <__bad_interrupt>
 1ea:	00 00       	nop
 1ec:	22 c0       	rjmp	.+68     	; 0x232 <__bad_interrupt>
 1ee:	00 00       	nop
 1f0:	20 c0       	rjmp	.+64     	; 0x232 <__bad_interrupt>
 1f2:	00 00       	nop
 1f4:	1e c0       	rjmp	.+60     	; 0x232 <__bad_interrupt>
 1f6:	00 00       	nop
 1f8:	1c c0       	rjmp	.+56     	; 0x232 <__bad_interrupt>
	...

000001fc <__ctors_end>:
 1fc:	11 24       	eor	r1, r1
 1fe:	1f be       	out	0x3f, r1	; 63
 200:	cf ef       	ldi	r28, 0xFF	; 255
 202:	cd bf       	out	0x3d, r28	; 61
 204:	df e2       	ldi	r29, 0x2F	; 47
 206:	de bf       	out	0x3e, r29	; 62

00000208 <__do_copy_data>:
 208:	10 e2       	ldi	r17, 0x20	; 32
 20a:	a0 e0       	ldi	r26, 0x00	; 0
 20c:	b0 e2       	ldi	r27, 0x20	; 32
 20e:	e8 ed       	ldi	r30, 0xD8	; 216
 210:	fc e0       	ldi	r31, 0x0C	; 12
 212:	02 c0       	rjmp	.+4      	; 0x218 <__do_copy_data+0x10>
 214:	05 90       	lpm	r0, Z+
 216:	0d 92       	st	X+, r0
 218:	a6 33       	cpi	r26, 0x36	; 54
 21a:	b1 07       	cpc	r27, r17
 21c:	d9 f7       	brne	.-10     	; 0x214 <__do_copy_data+0xc>

0000021e <__do_clear_bss>:
 21e:	20 e2       	ldi	r18, 0x20	; 32
 220:	a6 e3       	ldi	r26, 0x36	; 54
 222:	b0 e2       	ldi	r27, 0x20	; 32
 224:	01 c0       	rjmp	.+2      	; 0x228 <.do_clear_bss_start>

00000226 <.do_clear_bss_loop>:
 226:	1d 92       	st	X+, r1

00000228 <.do_clear_bss_start>:
 228:	aa 36       	cpi	r26, 0x6A	; 106
 22a:	b2 07       	cpc	r27, r18
 22c:	e1 f7       	brne	.-8      	; 0x226 <.do_clear_bss_loop>
 22e:	bb d4       	rcall	.+2422   	; 0xba6 <main>
 230:	51 c5       	rjmp	.+2722   	; 0xcd4 <_exit>

00000232 <__bad_interrupt>:
 232:	e6 ce       	rjmp	.-564    	; 0x0 <__vectors>

00000234 <__vector_14>:
 *
 * This function will handle interrupt on Timer Counter CO overflow and
 * call the callback function.
 */
ISR(TCC0_OVF_vect)
{
 234:	1f 92       	push	r1
 236:	0f 92       	push	r0
 238:	0f b6       	in	r0, 0x3f	; 63
 23a:	0f 92       	push	r0
 23c:	11 24       	eor	r1, r1
 23e:	2f 93       	push	r18
 240:	3f 93       	push	r19
 242:	4f 93       	push	r20
 244:	5f 93       	push	r21
 246:	6f 93       	push	r22
 248:	7f 93       	push	r23
 24a:	8f 93       	push	r24
 24c:	9f 93       	push	r25
 24e:	af 93       	push	r26
 250:	bf 93       	push	r27
 252:	ef 93       	push	r30
 254:	ff 93       	push	r31
	if (tc_tcc0_ovf_callback) {
 256:	e0 91 68 20 	lds	r30, 0x2068	; 0x802068 <tc_tcc0_ovf_callback>
 25a:	f0 91 69 20 	lds	r31, 0x2069	; 0x802069 <tc_tcc0_ovf_callback+0x1>
 25e:	30 97       	sbiw	r30, 0x00	; 0
 260:	09 f0       	breq	.+2      	; 0x264 <__vector_14+0x30>
		tc_tcc0_ovf_callback();
 262:	09 95       	icall
	}
}
 264:	ff 91       	pop	r31
 266:	ef 91       	pop	r30
 268:	bf 91       	pop	r27
 26a:	af 91       	pop	r26
 26c:	9f 91       	pop	r25
 26e:	8f 91       	pop	r24
 270:	7f 91       	pop	r23
 272:	6f 91       	pop	r22
 274:	5f 91       	pop	r21
 276:	4f 91       	pop	r20
 278:	3f 91       	pop	r19
 27a:	2f 91       	pop	r18
 27c:	0f 90       	pop	r0
 27e:	0f be       	out	0x3f, r0	; 63
 280:	0f 90       	pop	r0
 282:	1f 90       	pop	r1
 284:	18 95       	reti

00000286 <__vector_15>:
 *
 * This function will handle interrupt on Timer Counter CO error and
 * call the callback function.
 */
ISR(TCC0_ERR_vect)
{
 286:	1f 92       	push	r1
 288:	0f 92       	push	r0
 28a:	0f b6       	in	r0, 0x3f	; 63
 28c:	0f 92       	push	r0
 28e:	11 24       	eor	r1, r1
 290:	2f 93       	push	r18
 292:	3f 93       	push	r19
 294:	4f 93       	push	r20
 296:	5f 93       	push	r21
 298:	6f 93       	push	r22
 29a:	7f 93       	push	r23
 29c:	8f 93       	push	r24
 29e:	9f 93       	push	r25
 2a0:	af 93       	push	r26
 2a2:	bf 93       	push	r27
 2a4:	ef 93       	push	r30
 2a6:	ff 93       	push	r31
	if (tc_tcc0_err_callback) {
 2a8:	e0 91 66 20 	lds	r30, 0x2066	; 0x802066 <tc_tcc0_err_callback>
 2ac:	f0 91 67 20 	lds	r31, 0x2067	; 0x802067 <tc_tcc0_err_callback+0x1>
 2b0:	30 97       	sbiw	r30, 0x00	; 0
 2b2:	09 f0       	breq	.+2      	; 0x2b6 <__vector_15+0x30>
		tc_tcc0_err_callback();
 2b4:	09 95       	icall
	}
}
 2b6:	ff 91       	pop	r31
 2b8:	ef 91       	pop	r30
 2ba:	bf 91       	pop	r27
 2bc:	af 91       	pop	r26
 2be:	9f 91       	pop	r25
 2c0:	8f 91       	pop	r24
 2c2:	7f 91       	pop	r23
 2c4:	6f 91       	pop	r22
 2c6:	5f 91       	pop	r21
 2c8:	4f 91       	pop	r20
 2ca:	3f 91       	pop	r19
 2cc:	2f 91       	pop	r18
 2ce:	0f 90       	pop	r0
 2d0:	0f be       	out	0x3f, r0	; 63
 2d2:	0f 90       	pop	r0
 2d4:	1f 90       	pop	r1
 2d6:	18 95       	reti

000002d8 <__vector_16>:
 *
 * This function will handle interrupt on Timer Counter CO Compare/CaptureA and
 * call the callback function.
 */
ISR(TCC0_CCA_vect)
{
 2d8:	1f 92       	push	r1
 2da:	0f 92       	push	r0
 2dc:	0f b6       	in	r0, 0x3f	; 63
 2de:	0f 92       	push	r0
 2e0:	11 24       	eor	r1, r1
 2e2:	2f 93       	push	r18
 2e4:	3f 93       	push	r19
 2e6:	4f 93       	push	r20
 2e8:	5f 93       	push	r21
 2ea:	6f 93       	push	r22
 2ec:	7f 93       	push	r23
 2ee:	8f 93       	push	r24
 2f0:	9f 93       	push	r25
 2f2:	af 93       	push	r26
 2f4:	bf 93       	push	r27
 2f6:	ef 93       	push	r30
 2f8:	ff 93       	push	r31
	if (tc_tcc0_cca_callback) {
 2fa:	e0 91 64 20 	lds	r30, 0x2064	; 0x802064 <tc_tcc0_cca_callback>
 2fe:	f0 91 65 20 	lds	r31, 0x2065	; 0x802065 <tc_tcc0_cca_callback+0x1>
 302:	30 97       	sbiw	r30, 0x00	; 0
 304:	09 f0       	breq	.+2      	; 0x308 <__vector_16+0x30>
		tc_tcc0_cca_callback();
 306:	09 95       	icall
	}
}
 308:	ff 91       	pop	r31
 30a:	ef 91       	pop	r30
 30c:	bf 91       	pop	r27
 30e:	af 91       	pop	r26
 310:	9f 91       	pop	r25
 312:	8f 91       	pop	r24
 314:	7f 91       	pop	r23
 316:	6f 91       	pop	r22
 318:	5f 91       	pop	r21
 31a:	4f 91       	pop	r20
 31c:	3f 91       	pop	r19
 31e:	2f 91       	pop	r18
 320:	0f 90       	pop	r0
 322:	0f be       	out	0x3f, r0	; 63
 324:	0f 90       	pop	r0
 326:	1f 90       	pop	r1
 328:	18 95       	reti

0000032a <__vector_17>:
 *
 * This function will handle interrupt on Timer Counter CO Compare/CaptureB and
 * call the callback function.
 */
ISR(TCC0_CCB_vect)
{
 32a:	1f 92       	push	r1
 32c:	0f 92       	push	r0
 32e:	0f b6       	in	r0, 0x3f	; 63
 330:	0f 92       	push	r0
 332:	11 24       	eor	r1, r1
 334:	2f 93       	push	r18
 336:	3f 93       	push	r19
 338:	4f 93       	push	r20
 33a:	5f 93       	push	r21
 33c:	6f 93       	push	r22
 33e:	7f 93       	push	r23
 340:	8f 93       	push	r24
 342:	9f 93       	push	r25
 344:	af 93       	push	r26
 346:	bf 93       	push	r27
 348:	ef 93       	push	r30
 34a:	ff 93       	push	r31
	if (tc_tcc0_ccb_callback) {
 34c:	e0 91 62 20 	lds	r30, 0x2062	; 0x802062 <tc_tcc0_ccb_callback>
 350:	f0 91 63 20 	lds	r31, 0x2063	; 0x802063 <tc_tcc0_ccb_callback+0x1>
 354:	30 97       	sbiw	r30, 0x00	; 0
 356:	09 f0       	breq	.+2      	; 0x35a <__vector_17+0x30>
		tc_tcc0_ccb_callback();
 358:	09 95       	icall
	}
}
 35a:	ff 91       	pop	r31
 35c:	ef 91       	pop	r30
 35e:	bf 91       	pop	r27
 360:	af 91       	pop	r26
 362:	9f 91       	pop	r25
 364:	8f 91       	pop	r24
 366:	7f 91       	pop	r23
 368:	6f 91       	pop	r22
 36a:	5f 91       	pop	r21
 36c:	4f 91       	pop	r20
 36e:	3f 91       	pop	r19
 370:	2f 91       	pop	r18
 372:	0f 90       	pop	r0
 374:	0f be       	out	0x3f, r0	; 63
 376:	0f 90       	pop	r0
 378:	1f 90       	pop	r1
 37a:	18 95       	reti

0000037c <__vector_18>:
 *
 * This function will handle interrupt on Timer Counter CO Compare/CaptureC and
 * call the callback function.
 */
ISR(TCC0_CCC_vect)
{
 37c:	1f 92       	push	r1
 37e:	0f 92       	push	r0
 380:	0f b6       	in	r0, 0x3f	; 63
 382:	0f 92       	push	r0
 384:	11 24       	eor	r1, r1
 386:	2f 93       	push	r18
 388:	3f 93       	push	r19
 38a:	4f 93       	push	r20
 38c:	5f 93       	push	r21
 38e:	6f 93       	push	r22
 390:	7f 93       	push	r23
 392:	8f 93       	push	r24
 394:	9f 93       	push	r25
 396:	af 93       	push	r26
 398:	bf 93       	push	r27
 39a:	ef 93       	push	r30
 39c:	ff 93       	push	r31
	if (tc_tcc0_ccc_callback) {
 39e:	e0 91 60 20 	lds	r30, 0x2060	; 0x802060 <tc_tcc0_ccc_callback>
 3a2:	f0 91 61 20 	lds	r31, 0x2061	; 0x802061 <tc_tcc0_ccc_callback+0x1>
 3a6:	30 97       	sbiw	r30, 0x00	; 0
 3a8:	09 f0       	breq	.+2      	; 0x3ac <__vector_18+0x30>
		tc_tcc0_ccc_callback();
 3aa:	09 95       	icall
	}
}
 3ac:	ff 91       	pop	r31
 3ae:	ef 91       	pop	r30
 3b0:	bf 91       	pop	r27
 3b2:	af 91       	pop	r26
 3b4:	9f 91       	pop	r25
 3b6:	8f 91       	pop	r24
 3b8:	7f 91       	pop	r23
 3ba:	6f 91       	pop	r22
 3bc:	5f 91       	pop	r21
 3be:	4f 91       	pop	r20
 3c0:	3f 91       	pop	r19
 3c2:	2f 91       	pop	r18
 3c4:	0f 90       	pop	r0
 3c6:	0f be       	out	0x3f, r0	; 63
 3c8:	0f 90       	pop	r0
 3ca:	1f 90       	pop	r1
 3cc:	18 95       	reti

000003ce <__vector_19>:
 *
 * This function will handle interrupt on Timer Counter CO Compare/CaptureD and
 * call the callback function.
 */
ISR(TCC0_CCD_vect)
{
 3ce:	1f 92       	push	r1
 3d0:	0f 92       	push	r0
 3d2:	0f b6       	in	r0, 0x3f	; 63
 3d4:	0f 92       	push	r0
 3d6:	11 24       	eor	r1, r1
 3d8:	2f 93       	push	r18
 3da:	3f 93       	push	r19
 3dc:	4f 93       	push	r20
 3de:	5f 93       	push	r21
 3e0:	6f 93       	push	r22
 3e2:	7f 93       	push	r23
 3e4:	8f 93       	push	r24
 3e6:	9f 93       	push	r25
 3e8:	af 93       	push	r26
 3ea:	bf 93       	push	r27
 3ec:	ef 93       	push	r30
 3ee:	ff 93       	push	r31
	if (tc_tcc0_ccd_callback) {
 3f0:	e0 91 5e 20 	lds	r30, 0x205E	; 0x80205e <tc_tcc0_ccd_callback>
 3f4:	f0 91 5f 20 	lds	r31, 0x205F	; 0x80205f <tc_tcc0_ccd_callback+0x1>
 3f8:	30 97       	sbiw	r30, 0x00	; 0
 3fa:	09 f0       	breq	.+2      	; 0x3fe <__vector_19+0x30>
		tc_tcc0_ccd_callback();
 3fc:	09 95       	icall
	}
}
 3fe:	ff 91       	pop	r31
 400:	ef 91       	pop	r30
 402:	bf 91       	pop	r27
 404:	af 91       	pop	r26
 406:	9f 91       	pop	r25
 408:	8f 91       	pop	r24
 40a:	7f 91       	pop	r23
 40c:	6f 91       	pop	r22
 40e:	5f 91       	pop	r21
 410:	4f 91       	pop	r20
 412:	3f 91       	pop	r19
 414:	2f 91       	pop	r18
 416:	0f 90       	pop	r0
 418:	0f be       	out	0x3f, r0	; 63
 41a:	0f 90       	pop	r0
 41c:	1f 90       	pop	r1
 41e:	18 95       	reti

00000420 <__vector_20>:
 *
 * This function will handle interrupt on Timer Counter C1 overflow and
 * call the callback function.
 */
ISR(TCC1_OVF_vect)
{
 420:	1f 92       	push	r1
 422:	0f 92       	push	r0
 424:	0f b6       	in	r0, 0x3f	; 63
 426:	0f 92       	push	r0
 428:	11 24       	eor	r1, r1
 42a:	2f 93       	push	r18
 42c:	3f 93       	push	r19
 42e:	4f 93       	push	r20
 430:	5f 93       	push	r21
 432:	6f 93       	push	r22
 434:	7f 93       	push	r23
 436:	8f 93       	push	r24
 438:	9f 93       	push	r25
 43a:	af 93       	push	r26
 43c:	bf 93       	push	r27
 43e:	ef 93       	push	r30
 440:	ff 93       	push	r31
	if (tc_tcc1_ovf_callback) {
 442:	e0 91 5c 20 	lds	r30, 0x205C	; 0x80205c <tc_tcc1_ovf_callback>
 446:	f0 91 5d 20 	lds	r31, 0x205D	; 0x80205d <tc_tcc1_ovf_callback+0x1>
 44a:	30 97       	sbiw	r30, 0x00	; 0
 44c:	09 f0       	breq	.+2      	; 0x450 <__vector_20+0x30>
		tc_tcc1_ovf_callback();
 44e:	09 95       	icall
	}
}
 450:	ff 91       	pop	r31
 452:	ef 91       	pop	r30
 454:	bf 91       	pop	r27
 456:	af 91       	pop	r26
 458:	9f 91       	pop	r25
 45a:	8f 91       	pop	r24
 45c:	7f 91       	pop	r23
 45e:	6f 91       	pop	r22
 460:	5f 91       	pop	r21
 462:	4f 91       	pop	r20
 464:	3f 91       	pop	r19
 466:	2f 91       	pop	r18
 468:	0f 90       	pop	r0
 46a:	0f be       	out	0x3f, r0	; 63
 46c:	0f 90       	pop	r0
 46e:	1f 90       	pop	r1
 470:	18 95       	reti

00000472 <__vector_21>:
 *
 * This function will handle interrupt on Timer Counter C1 error and
 * call the callback function.
 */
ISR(TCC1_ERR_vect)
{
 472:	1f 92       	push	r1
 474:	0f 92       	push	r0
 476:	0f b6       	in	r0, 0x3f	; 63
 478:	0f 92       	push	r0
 47a:	11 24       	eor	r1, r1
 47c:	2f 93       	push	r18
 47e:	3f 93       	push	r19
 480:	4f 93       	push	r20
 482:	5f 93       	push	r21
 484:	6f 93       	push	r22
 486:	7f 93       	push	r23
 488:	8f 93       	push	r24
 48a:	9f 93       	push	r25
 48c:	af 93       	push	r26
 48e:	bf 93       	push	r27
 490:	ef 93       	push	r30
 492:	ff 93       	push	r31
	if (tc_tcc1_err_callback) {
 494:	e0 91 5a 20 	lds	r30, 0x205A	; 0x80205a <tc_tcc1_err_callback>
 498:	f0 91 5b 20 	lds	r31, 0x205B	; 0x80205b <tc_tcc1_err_callback+0x1>
 49c:	30 97       	sbiw	r30, 0x00	; 0
 49e:	09 f0       	breq	.+2      	; 0x4a2 <__vector_21+0x30>
		tc_tcc1_err_callback();
 4a0:	09 95       	icall
	}
}
 4a2:	ff 91       	pop	r31
 4a4:	ef 91       	pop	r30
 4a6:	bf 91       	pop	r27
 4a8:	af 91       	pop	r26
 4aa:	9f 91       	pop	r25
 4ac:	8f 91       	pop	r24
 4ae:	7f 91       	pop	r23
 4b0:	6f 91       	pop	r22
 4b2:	5f 91       	pop	r21
 4b4:	4f 91       	pop	r20
 4b6:	3f 91       	pop	r19
 4b8:	2f 91       	pop	r18
 4ba:	0f 90       	pop	r0
 4bc:	0f be       	out	0x3f, r0	; 63
 4be:	0f 90       	pop	r0
 4c0:	1f 90       	pop	r1
 4c2:	18 95       	reti

000004c4 <__vector_22>:
 *
 * This function will handle interrupt on Timer Counter C1 Compare/CaptureA and
 * call the callback function.
 */
ISR(TCC1_CCA_vect)
{
 4c4:	1f 92       	push	r1
 4c6:	0f 92       	push	r0
 4c8:	0f b6       	in	r0, 0x3f	; 63
 4ca:	0f 92       	push	r0
 4cc:	11 24       	eor	r1, r1
 4ce:	2f 93       	push	r18
 4d0:	3f 93       	push	r19
 4d2:	4f 93       	push	r20
 4d4:	5f 93       	push	r21
 4d6:	6f 93       	push	r22
 4d8:	7f 93       	push	r23
 4da:	8f 93       	push	r24
 4dc:	9f 93       	push	r25
 4de:	af 93       	push	r26
 4e0:	bf 93       	push	r27
 4e2:	ef 93       	push	r30
 4e4:	ff 93       	push	r31
	if (tc_tcc1_cca_callback) {
 4e6:	e0 91 58 20 	lds	r30, 0x2058	; 0x802058 <tc_tcc1_cca_callback>
 4ea:	f0 91 59 20 	lds	r31, 0x2059	; 0x802059 <tc_tcc1_cca_callback+0x1>
 4ee:	30 97       	sbiw	r30, 0x00	; 0
 4f0:	09 f0       	breq	.+2      	; 0x4f4 <__vector_22+0x30>
		tc_tcc1_cca_callback();
 4f2:	09 95       	icall
	}
}
 4f4:	ff 91       	pop	r31
 4f6:	ef 91       	pop	r30
 4f8:	bf 91       	pop	r27
 4fa:	af 91       	pop	r26
 4fc:	9f 91       	pop	r25
 4fe:	8f 91       	pop	r24
 500:	7f 91       	pop	r23
 502:	6f 91       	pop	r22
 504:	5f 91       	pop	r21
 506:	4f 91       	pop	r20
 508:	3f 91       	pop	r19
 50a:	2f 91       	pop	r18
 50c:	0f 90       	pop	r0
 50e:	0f be       	out	0x3f, r0	; 63
 510:	0f 90       	pop	r0
 512:	1f 90       	pop	r1
 514:	18 95       	reti

00000516 <__vector_23>:
 *
 * This function will handle interrupt on Timer Counter C1 Compare/CaptureB and
 * call the callback function.
 */
ISR(TCC1_CCB_vect)
{
 516:	1f 92       	push	r1
 518:	0f 92       	push	r0
 51a:	0f b6       	in	r0, 0x3f	; 63
 51c:	0f 92       	push	r0
 51e:	11 24       	eor	r1, r1
 520:	2f 93       	push	r18
 522:	3f 93       	push	r19
 524:	4f 93       	push	r20
 526:	5f 93       	push	r21
 528:	6f 93       	push	r22
 52a:	7f 93       	push	r23
 52c:	8f 93       	push	r24
 52e:	9f 93       	push	r25
 530:	af 93       	push	r26
 532:	bf 93       	push	r27
 534:	ef 93       	push	r30
 536:	ff 93       	push	r31
	if (tc_tcc1_ccb_callback) {
 538:	e0 91 56 20 	lds	r30, 0x2056	; 0x802056 <tc_tcc1_ccb_callback>
 53c:	f0 91 57 20 	lds	r31, 0x2057	; 0x802057 <tc_tcc1_ccb_callback+0x1>
 540:	30 97       	sbiw	r30, 0x00	; 0
 542:	09 f0       	breq	.+2      	; 0x546 <__vector_23+0x30>
		tc_tcc1_ccb_callback();
 544:	09 95       	icall
	}
}
 546:	ff 91       	pop	r31
 548:	ef 91       	pop	r30
 54a:	bf 91       	pop	r27
 54c:	af 91       	pop	r26
 54e:	9f 91       	pop	r25
 550:	8f 91       	pop	r24
 552:	7f 91       	pop	r23
 554:	6f 91       	pop	r22
 556:	5f 91       	pop	r21
 558:	4f 91       	pop	r20
 55a:	3f 91       	pop	r19
 55c:	2f 91       	pop	r18
 55e:	0f 90       	pop	r0
 560:	0f be       	out	0x3f, r0	; 63
 562:	0f 90       	pop	r0
 564:	1f 90       	pop	r1
 566:	18 95       	reti

00000568 <__vector_77>:
 *
 * This function will handle interrupt on Timer Counter D0 overflow and
 * call the callback function.
 */
ISR(TCD0_OVF_vect)
{
 568:	1f 92       	push	r1
 56a:	0f 92       	push	r0
 56c:	0f b6       	in	r0, 0x3f	; 63
 56e:	0f 92       	push	r0
 570:	11 24       	eor	r1, r1
 572:	2f 93       	push	r18
 574:	3f 93       	push	r19
 576:	4f 93       	push	r20
 578:	5f 93       	push	r21
 57a:	6f 93       	push	r22
 57c:	7f 93       	push	r23
 57e:	8f 93       	push	r24
 580:	9f 93       	push	r25
 582:	af 93       	push	r26
 584:	bf 93       	push	r27
 586:	ef 93       	push	r30
 588:	ff 93       	push	r31
	if (tc_tcd0_ovf_callback) {
 58a:	e0 91 54 20 	lds	r30, 0x2054	; 0x802054 <tc_tcd0_ovf_callback>
 58e:	f0 91 55 20 	lds	r31, 0x2055	; 0x802055 <tc_tcd0_ovf_callback+0x1>
 592:	30 97       	sbiw	r30, 0x00	; 0
 594:	09 f0       	breq	.+2      	; 0x598 <__vector_77+0x30>
		tc_tcd0_ovf_callback();
 596:	09 95       	icall
	}
}
 598:	ff 91       	pop	r31
 59a:	ef 91       	pop	r30
 59c:	bf 91       	pop	r27
 59e:	af 91       	pop	r26
 5a0:	9f 91       	pop	r25
 5a2:	8f 91       	pop	r24
 5a4:	7f 91       	pop	r23
 5a6:	6f 91       	pop	r22
 5a8:	5f 91       	pop	r21
 5aa:	4f 91       	pop	r20
 5ac:	3f 91       	pop	r19
 5ae:	2f 91       	pop	r18
 5b0:	0f 90       	pop	r0
 5b2:	0f be       	out	0x3f, r0	; 63
 5b4:	0f 90       	pop	r0
 5b6:	1f 90       	pop	r1
 5b8:	18 95       	reti

000005ba <__vector_78>:
 *
 * This function will handle interrupt on Timer Counter D0 error and
 * call the callback function.
 */
ISR(TCD0_ERR_vect)
{
 5ba:	1f 92       	push	r1
 5bc:	0f 92       	push	r0
 5be:	0f b6       	in	r0, 0x3f	; 63
 5c0:	0f 92       	push	r0
 5c2:	11 24       	eor	r1, r1
 5c4:	2f 93       	push	r18
 5c6:	3f 93       	push	r19
 5c8:	4f 93       	push	r20
 5ca:	5f 93       	push	r21
 5cc:	6f 93       	push	r22
 5ce:	7f 93       	push	r23
 5d0:	8f 93       	push	r24
 5d2:	9f 93       	push	r25
 5d4:	af 93       	push	r26
 5d6:	bf 93       	push	r27
 5d8:	ef 93       	push	r30
 5da:	ff 93       	push	r31
	if (tc_tcd0_err_callback) {
 5dc:	e0 91 52 20 	lds	r30, 0x2052	; 0x802052 <tc_tcd0_err_callback>
 5e0:	f0 91 53 20 	lds	r31, 0x2053	; 0x802053 <tc_tcd0_err_callback+0x1>
 5e4:	30 97       	sbiw	r30, 0x00	; 0
 5e6:	09 f0       	breq	.+2      	; 0x5ea <__vector_78+0x30>
		tc_tcd0_err_callback();
 5e8:	09 95       	icall
	}
}
 5ea:	ff 91       	pop	r31
 5ec:	ef 91       	pop	r30
 5ee:	bf 91       	pop	r27
 5f0:	af 91       	pop	r26
 5f2:	9f 91       	pop	r25
 5f4:	8f 91       	pop	r24
 5f6:	7f 91       	pop	r23
 5f8:	6f 91       	pop	r22
 5fa:	5f 91       	pop	r21
 5fc:	4f 91       	pop	r20
 5fe:	3f 91       	pop	r19
 600:	2f 91       	pop	r18
 602:	0f 90       	pop	r0
 604:	0f be       	out	0x3f, r0	; 63
 606:	0f 90       	pop	r0
 608:	1f 90       	pop	r1
 60a:	18 95       	reti

0000060c <__vector_79>:
 *
 * This function will handle interrupt on Timer Counter D0 Compare/CaptureA and
 * call the callback function.
 */
ISR(TCD0_CCA_vect)
{
 60c:	1f 92       	push	r1
 60e:	0f 92       	push	r0
 610:	0f b6       	in	r0, 0x3f	; 63
 612:	0f 92       	push	r0
 614:	11 24       	eor	r1, r1
 616:	2f 93       	push	r18
 618:	3f 93       	push	r19
 61a:	4f 93       	push	r20
 61c:	5f 93       	push	r21
 61e:	6f 93       	push	r22
 620:	7f 93       	push	r23
 622:	8f 93       	push	r24
 624:	9f 93       	push	r25
 626:	af 93       	push	r26
 628:	bf 93       	push	r27
 62a:	ef 93       	push	r30
 62c:	ff 93       	push	r31
	if (tc_tcd0_cca_callback) {
 62e:	e0 91 50 20 	lds	r30, 0x2050	; 0x802050 <tc_tcd0_cca_callback>
 632:	f0 91 51 20 	lds	r31, 0x2051	; 0x802051 <tc_tcd0_cca_callback+0x1>
 636:	30 97       	sbiw	r30, 0x00	; 0
 638:	09 f0       	breq	.+2      	; 0x63c <__vector_79+0x30>
		tc_tcd0_cca_callback();
 63a:	09 95       	icall
	}
}
 63c:	ff 91       	pop	r31
 63e:	ef 91       	pop	r30
 640:	bf 91       	pop	r27
 642:	af 91       	pop	r26
 644:	9f 91       	pop	r25
 646:	8f 91       	pop	r24
 648:	7f 91       	pop	r23
 64a:	6f 91       	pop	r22
 64c:	5f 91       	pop	r21
 64e:	4f 91       	pop	r20
 650:	3f 91       	pop	r19
 652:	2f 91       	pop	r18
 654:	0f 90       	pop	r0
 656:	0f be       	out	0x3f, r0	; 63
 658:	0f 90       	pop	r0
 65a:	1f 90       	pop	r1
 65c:	18 95       	reti

0000065e <__vector_80>:
 *
 * This function will handle interrupt on Timer Counter D0 Compare/CaptureB and
 * call the callback function.
 */
ISR(TCD0_CCB_vect)
{
 65e:	1f 92       	push	r1
 660:	0f 92       	push	r0
 662:	0f b6       	in	r0, 0x3f	; 63
 664:	0f 92       	push	r0
 666:	11 24       	eor	r1, r1
 668:	2f 93       	push	r18
 66a:	3f 93       	push	r19
 66c:	4f 93       	push	r20
 66e:	5f 93       	push	r21
 670:	6f 93       	push	r22
 672:	7f 93       	push	r23
 674:	8f 93       	push	r24
 676:	9f 93       	push	r25
 678:	af 93       	push	r26
 67a:	bf 93       	push	r27
 67c:	ef 93       	push	r30
 67e:	ff 93       	push	r31
	if (tc_tcd0_ccb_callback) {
 680:	e0 91 4e 20 	lds	r30, 0x204E	; 0x80204e <tc_tcd0_ccb_callback>
 684:	f0 91 4f 20 	lds	r31, 0x204F	; 0x80204f <tc_tcd0_ccb_callback+0x1>
 688:	30 97       	sbiw	r30, 0x00	; 0
 68a:	09 f0       	breq	.+2      	; 0x68e <__vector_80+0x30>
		tc_tcd0_ccb_callback();
 68c:	09 95       	icall
	}
}
 68e:	ff 91       	pop	r31
 690:	ef 91       	pop	r30
 692:	bf 91       	pop	r27
 694:	af 91       	pop	r26
 696:	9f 91       	pop	r25
 698:	8f 91       	pop	r24
 69a:	7f 91       	pop	r23
 69c:	6f 91       	pop	r22
 69e:	5f 91       	pop	r21
 6a0:	4f 91       	pop	r20
 6a2:	3f 91       	pop	r19
 6a4:	2f 91       	pop	r18
 6a6:	0f 90       	pop	r0
 6a8:	0f be       	out	0x3f, r0	; 63
 6aa:	0f 90       	pop	r0
 6ac:	1f 90       	pop	r1
 6ae:	18 95       	reti

000006b0 <__vector_81>:
 *
 * This function will handle interrupt on Timer Counter D0 Compare/CaptureC and
 * call the callback function.
 */
ISR(TCD0_CCC_vect)
{
 6b0:	1f 92       	push	r1
 6b2:	0f 92       	push	r0
 6b4:	0f b6       	in	r0, 0x3f	; 63
 6b6:	0f 92       	push	r0
 6b8:	11 24       	eor	r1, r1
 6ba:	2f 93       	push	r18
 6bc:	3f 93       	push	r19
 6be:	4f 93       	push	r20
 6c0:	5f 93       	push	r21
 6c2:	6f 93       	push	r22
 6c4:	7f 93       	push	r23
 6c6:	8f 93       	push	r24
 6c8:	9f 93       	push	r25
 6ca:	af 93       	push	r26
 6cc:	bf 93       	push	r27
 6ce:	ef 93       	push	r30
 6d0:	ff 93       	push	r31
	if (tc_tcd0_ccc_callback) {
 6d2:	e0 91 4c 20 	lds	r30, 0x204C	; 0x80204c <tc_tcd0_ccc_callback>
 6d6:	f0 91 4d 20 	lds	r31, 0x204D	; 0x80204d <tc_tcd0_ccc_callback+0x1>
 6da:	30 97       	sbiw	r30, 0x00	; 0
 6dc:	09 f0       	breq	.+2      	; 0x6e0 <__vector_81+0x30>
		tc_tcd0_ccc_callback();
 6de:	09 95       	icall
	}
}
 6e0:	ff 91       	pop	r31
 6e2:	ef 91       	pop	r30
 6e4:	bf 91       	pop	r27
 6e6:	af 91       	pop	r26
 6e8:	9f 91       	pop	r25
 6ea:	8f 91       	pop	r24
 6ec:	7f 91       	pop	r23
 6ee:	6f 91       	pop	r22
 6f0:	5f 91       	pop	r21
 6f2:	4f 91       	pop	r20
 6f4:	3f 91       	pop	r19
 6f6:	2f 91       	pop	r18
 6f8:	0f 90       	pop	r0
 6fa:	0f be       	out	0x3f, r0	; 63
 6fc:	0f 90       	pop	r0
 6fe:	1f 90       	pop	r1
 700:	18 95       	reti

00000702 <__vector_82>:
 *
 * This function will handle interrupt on Timer Counter D0 Compare/CaptureD and
 * call the callback function.
 */
ISR(TCD0_CCD_vect)
{
 702:	1f 92       	push	r1
 704:	0f 92       	push	r0
 706:	0f b6       	in	r0, 0x3f	; 63
 708:	0f 92       	push	r0
 70a:	11 24       	eor	r1, r1
 70c:	2f 93       	push	r18
 70e:	3f 93       	push	r19
 710:	4f 93       	push	r20
 712:	5f 93       	push	r21
 714:	6f 93       	push	r22
 716:	7f 93       	push	r23
 718:	8f 93       	push	r24
 71a:	9f 93       	push	r25
 71c:	af 93       	push	r26
 71e:	bf 93       	push	r27
 720:	ef 93       	push	r30
 722:	ff 93       	push	r31
	if (tc_tcd0_ccd_callback) {
 724:	e0 91 4a 20 	lds	r30, 0x204A	; 0x80204a <tc_tcd0_ccd_callback>
 728:	f0 91 4b 20 	lds	r31, 0x204B	; 0x80204b <tc_tcd0_ccd_callback+0x1>
 72c:	30 97       	sbiw	r30, 0x00	; 0
 72e:	09 f0       	breq	.+2      	; 0x732 <__vector_82+0x30>
		tc_tcd0_ccd_callback();
 730:	09 95       	icall
	}
}
 732:	ff 91       	pop	r31
 734:	ef 91       	pop	r30
 736:	bf 91       	pop	r27
 738:	af 91       	pop	r26
 73a:	9f 91       	pop	r25
 73c:	8f 91       	pop	r24
 73e:	7f 91       	pop	r23
 740:	6f 91       	pop	r22
 742:	5f 91       	pop	r21
 744:	4f 91       	pop	r20
 746:	3f 91       	pop	r19
 748:	2f 91       	pop	r18
 74a:	0f 90       	pop	r0
 74c:	0f be       	out	0x3f, r0	; 63
 74e:	0f 90       	pop	r0
 750:	1f 90       	pop	r1
 752:	18 95       	reti

00000754 <__vector_83>:
 *
 * This function will handle interrupt on Timer Counter D1 overflow and
 * call the callback function.
 */
ISR(TCD1_OVF_vect)
{
 754:	1f 92       	push	r1
 756:	0f 92       	push	r0
 758:	0f b6       	in	r0, 0x3f	; 63
 75a:	0f 92       	push	r0
 75c:	11 24       	eor	r1, r1
 75e:	2f 93       	push	r18
 760:	3f 93       	push	r19
 762:	4f 93       	push	r20
 764:	5f 93       	push	r21
 766:	6f 93       	push	r22
 768:	7f 93       	push	r23
 76a:	8f 93       	push	r24
 76c:	9f 93       	push	r25
 76e:	af 93       	push	r26
 770:	bf 93       	push	r27
 772:	ef 93       	push	r30
 774:	ff 93       	push	r31
	if (tc_tcd1_ovf_callback) {
 776:	e0 91 48 20 	lds	r30, 0x2048	; 0x802048 <tc_tcd1_ovf_callback>
 77a:	f0 91 49 20 	lds	r31, 0x2049	; 0x802049 <tc_tcd1_ovf_callback+0x1>
 77e:	30 97       	sbiw	r30, 0x00	; 0
 780:	09 f0       	breq	.+2      	; 0x784 <__vector_83+0x30>
		tc_tcd1_ovf_callback();
 782:	09 95       	icall
	}
}
 784:	ff 91       	pop	r31
 786:	ef 91       	pop	r30
 788:	bf 91       	pop	r27
 78a:	af 91       	pop	r26
 78c:	9f 91       	pop	r25
 78e:	8f 91       	pop	r24
 790:	7f 91       	pop	r23
 792:	6f 91       	pop	r22
 794:	5f 91       	pop	r21
 796:	4f 91       	pop	r20
 798:	3f 91       	pop	r19
 79a:	2f 91       	pop	r18
 79c:	0f 90       	pop	r0
 79e:	0f be       	out	0x3f, r0	; 63
 7a0:	0f 90       	pop	r0
 7a2:	1f 90       	pop	r1
 7a4:	18 95       	reti

000007a6 <__vector_84>:
 *
 * This function will handle interrupt on Timer Counter D1 error and
 * call the callback function.
 */
ISR(TCD1_ERR_vect)
{
 7a6:	1f 92       	push	r1
 7a8:	0f 92       	push	r0
 7aa:	0f b6       	in	r0, 0x3f	; 63
 7ac:	0f 92       	push	r0
 7ae:	11 24       	eor	r1, r1
 7b0:	2f 93       	push	r18
 7b2:	3f 93       	push	r19
 7b4:	4f 93       	push	r20
 7b6:	5f 93       	push	r21
 7b8:	6f 93       	push	r22
 7ba:	7f 93       	push	r23
 7bc:	8f 93       	push	r24
 7be:	9f 93       	push	r25
 7c0:	af 93       	push	r26
 7c2:	bf 93       	push	r27
 7c4:	ef 93       	push	r30
 7c6:	ff 93       	push	r31
	if (tc_tcd1_err_callback) {
 7c8:	e0 91 46 20 	lds	r30, 0x2046	; 0x802046 <tc_tcd1_err_callback>
 7cc:	f0 91 47 20 	lds	r31, 0x2047	; 0x802047 <tc_tcd1_err_callback+0x1>
 7d0:	30 97       	sbiw	r30, 0x00	; 0
 7d2:	09 f0       	breq	.+2      	; 0x7d6 <__vector_84+0x30>
		tc_tcd1_err_callback();
 7d4:	09 95       	icall
	}
}
 7d6:	ff 91       	pop	r31
 7d8:	ef 91       	pop	r30
 7da:	bf 91       	pop	r27
 7dc:	af 91       	pop	r26
 7de:	9f 91       	pop	r25
 7e0:	8f 91       	pop	r24
 7e2:	7f 91       	pop	r23
 7e4:	6f 91       	pop	r22
 7e6:	5f 91       	pop	r21
 7e8:	4f 91       	pop	r20
 7ea:	3f 91       	pop	r19
 7ec:	2f 91       	pop	r18
 7ee:	0f 90       	pop	r0
 7f0:	0f be       	out	0x3f, r0	; 63
 7f2:	0f 90       	pop	r0
 7f4:	1f 90       	pop	r1
 7f6:	18 95       	reti

000007f8 <__vector_85>:
 *
 * This function will handle interrupt on Timer Counter D1 Compare/CaptureA and
 * call the callback function.
 */
ISR(TCD1_CCA_vect)
{
 7f8:	1f 92       	push	r1
 7fa:	0f 92       	push	r0
 7fc:	0f b6       	in	r0, 0x3f	; 63
 7fe:	0f 92       	push	r0
 800:	11 24       	eor	r1, r1
 802:	2f 93       	push	r18
 804:	3f 93       	push	r19
 806:	4f 93       	push	r20
 808:	5f 93       	push	r21
 80a:	6f 93       	push	r22
 80c:	7f 93       	push	r23
 80e:	8f 93       	push	r24
 810:	9f 93       	push	r25
 812:	af 93       	push	r26
 814:	bf 93       	push	r27
 816:	ef 93       	push	r30
 818:	ff 93       	push	r31
	if (tc_tcd1_cca_callback) {
 81a:	e0 91 44 20 	lds	r30, 0x2044	; 0x802044 <tc_tcd1_cca_callback>
 81e:	f0 91 45 20 	lds	r31, 0x2045	; 0x802045 <tc_tcd1_cca_callback+0x1>
 822:	30 97       	sbiw	r30, 0x00	; 0
 824:	09 f0       	breq	.+2      	; 0x828 <__vector_85+0x30>
		tc_tcd1_cca_callback();
 826:	09 95       	icall
	}
}
 828:	ff 91       	pop	r31
 82a:	ef 91       	pop	r30
 82c:	bf 91       	pop	r27
 82e:	af 91       	pop	r26
 830:	9f 91       	pop	r25
 832:	8f 91       	pop	r24
 834:	7f 91       	pop	r23
 836:	6f 91       	pop	r22
 838:	5f 91       	pop	r21
 83a:	4f 91       	pop	r20
 83c:	3f 91       	pop	r19
 83e:	2f 91       	pop	r18
 840:	0f 90       	pop	r0
 842:	0f be       	out	0x3f, r0	; 63
 844:	0f 90       	pop	r0
 846:	1f 90       	pop	r1
 848:	18 95       	reti

0000084a <__vector_86>:
 *
 * This function will handle interrupt on Timer Counter D1 Compare/CaptureB and
 * call the callback function.
 */
ISR(TCD1_CCB_vect)
{
 84a:	1f 92       	push	r1
 84c:	0f 92       	push	r0
 84e:	0f b6       	in	r0, 0x3f	; 63
 850:	0f 92       	push	r0
 852:	11 24       	eor	r1, r1
 854:	2f 93       	push	r18
 856:	3f 93       	push	r19
 858:	4f 93       	push	r20
 85a:	5f 93       	push	r21
 85c:	6f 93       	push	r22
 85e:	7f 93       	push	r23
 860:	8f 93       	push	r24
 862:	9f 93       	push	r25
 864:	af 93       	push	r26
 866:	bf 93       	push	r27
 868:	ef 93       	push	r30
 86a:	ff 93       	push	r31
	if (tc_tcd1_ccb_callback) {
 86c:	e0 91 42 20 	lds	r30, 0x2042	; 0x802042 <tc_tcd1_ccb_callback>
 870:	f0 91 43 20 	lds	r31, 0x2043	; 0x802043 <tc_tcd1_ccb_callback+0x1>
 874:	30 97       	sbiw	r30, 0x00	; 0
 876:	09 f0       	breq	.+2      	; 0x87a <__vector_86+0x30>
		tc_tcd1_ccb_callback();
 878:	09 95       	icall
	}
}
 87a:	ff 91       	pop	r31
 87c:	ef 91       	pop	r30
 87e:	bf 91       	pop	r27
 880:	af 91       	pop	r26
 882:	9f 91       	pop	r25
 884:	8f 91       	pop	r24
 886:	7f 91       	pop	r23
 888:	6f 91       	pop	r22
 88a:	5f 91       	pop	r21
 88c:	4f 91       	pop	r20
 88e:	3f 91       	pop	r19
 890:	2f 91       	pop	r18
 892:	0f 90       	pop	r0
 894:	0f be       	out	0x3f, r0	; 63
 896:	0f 90       	pop	r0
 898:	1f 90       	pop	r1
 89a:	18 95       	reti

0000089c <__vector_47>:
 *
 * This function will handle interrupt on Timer Counter E0 overflow and
 * call the callback function.
 */
ISR(TCE0_OVF_vect)
{
 89c:	1f 92       	push	r1
 89e:	0f 92       	push	r0
 8a0:	0f b6       	in	r0, 0x3f	; 63
 8a2:	0f 92       	push	r0
 8a4:	11 24       	eor	r1, r1
 8a6:	2f 93       	push	r18
 8a8:	3f 93       	push	r19
 8aa:	4f 93       	push	r20
 8ac:	5f 93       	push	r21
 8ae:	6f 93       	push	r22
 8b0:	7f 93       	push	r23
 8b2:	8f 93       	push	r24
 8b4:	9f 93       	push	r25
 8b6:	af 93       	push	r26
 8b8:	bf 93       	push	r27
 8ba:	ef 93       	push	r30
 8bc:	ff 93       	push	r31
	if (tc_tce0_ovf_callback) {
 8be:	e0 91 40 20 	lds	r30, 0x2040	; 0x802040 <tc_tce0_ovf_callback>
 8c2:	f0 91 41 20 	lds	r31, 0x2041	; 0x802041 <tc_tce0_ovf_callback+0x1>
 8c6:	30 97       	sbiw	r30, 0x00	; 0
 8c8:	09 f0       	breq	.+2      	; 0x8cc <__vector_47+0x30>
		tc_tce0_ovf_callback();
 8ca:	09 95       	icall
	}
}
 8cc:	ff 91       	pop	r31
 8ce:	ef 91       	pop	r30
 8d0:	bf 91       	pop	r27
 8d2:	af 91       	pop	r26
 8d4:	9f 91       	pop	r25
 8d6:	8f 91       	pop	r24
 8d8:	7f 91       	pop	r23
 8da:	6f 91       	pop	r22
 8dc:	5f 91       	pop	r21
 8de:	4f 91       	pop	r20
 8e0:	3f 91       	pop	r19
 8e2:	2f 91       	pop	r18
 8e4:	0f 90       	pop	r0
 8e6:	0f be       	out	0x3f, r0	; 63
 8e8:	0f 90       	pop	r0
 8ea:	1f 90       	pop	r1
 8ec:	18 95       	reti

000008ee <__vector_48>:
 *
 * This function will handle interrupt on Timer Counter E0 error and
 * call the callback function.
 */
ISR(TCE0_ERR_vect)
{
 8ee:	1f 92       	push	r1
 8f0:	0f 92       	push	r0
 8f2:	0f b6       	in	r0, 0x3f	; 63
 8f4:	0f 92       	push	r0
 8f6:	11 24       	eor	r1, r1
 8f8:	2f 93       	push	r18
 8fa:	3f 93       	push	r19
 8fc:	4f 93       	push	r20
 8fe:	5f 93       	push	r21
 900:	6f 93       	push	r22
 902:	7f 93       	push	r23
 904:	8f 93       	push	r24
 906:	9f 93       	push	r25
 908:	af 93       	push	r26
 90a:	bf 93       	push	r27
 90c:	ef 93       	push	r30
 90e:	ff 93       	push	r31
	if (tc_tce0_err_callback) {
 910:	e0 91 3e 20 	lds	r30, 0x203E	; 0x80203e <tc_tce0_err_callback>
 914:	f0 91 3f 20 	lds	r31, 0x203F	; 0x80203f <tc_tce0_err_callback+0x1>
 918:	30 97       	sbiw	r30, 0x00	; 0
 91a:	09 f0       	breq	.+2      	; 0x91e <__vector_48+0x30>
		tc_tce0_err_callback();
 91c:	09 95       	icall
	}
}
 91e:	ff 91       	pop	r31
 920:	ef 91       	pop	r30
 922:	bf 91       	pop	r27
 924:	af 91       	pop	r26
 926:	9f 91       	pop	r25
 928:	8f 91       	pop	r24
 92a:	7f 91       	pop	r23
 92c:	6f 91       	pop	r22
 92e:	5f 91       	pop	r21
 930:	4f 91       	pop	r20
 932:	3f 91       	pop	r19
 934:	2f 91       	pop	r18
 936:	0f 90       	pop	r0
 938:	0f be       	out	0x3f, r0	; 63
 93a:	0f 90       	pop	r0
 93c:	1f 90       	pop	r1
 93e:	18 95       	reti

00000940 <__vector_49>:
 *
 * This function will handle interrupt on Timer Counter E0 Compare/CaptureA and
 * call the callback function.
 */
ISR(TCE0_CCA_vect)
{
 940:	1f 92       	push	r1
 942:	0f 92       	push	r0
 944:	0f b6       	in	r0, 0x3f	; 63
 946:	0f 92       	push	r0
 948:	11 24       	eor	r1, r1
 94a:	2f 93       	push	r18
 94c:	3f 93       	push	r19
 94e:	4f 93       	push	r20
 950:	5f 93       	push	r21
 952:	6f 93       	push	r22
 954:	7f 93       	push	r23
 956:	8f 93       	push	r24
 958:	9f 93       	push	r25
 95a:	af 93       	push	r26
 95c:	bf 93       	push	r27
 95e:	ef 93       	push	r30
 960:	ff 93       	push	r31
	if (tc_tce0_cca_callback) {
 962:	e0 91 3c 20 	lds	r30, 0x203C	; 0x80203c <tc_tce0_cca_callback>
 966:	f0 91 3d 20 	lds	r31, 0x203D	; 0x80203d <tc_tce0_cca_callback+0x1>
 96a:	30 97       	sbiw	r30, 0x00	; 0
 96c:	09 f0       	breq	.+2      	; 0x970 <__vector_49+0x30>
		tc_tce0_cca_callback();
 96e:	09 95       	icall
	}
}
 970:	ff 91       	pop	r31
 972:	ef 91       	pop	r30
 974:	bf 91       	pop	r27
 976:	af 91       	pop	r26
 978:	9f 91       	pop	r25
 97a:	8f 91       	pop	r24
 97c:	7f 91       	pop	r23
 97e:	6f 91       	pop	r22
 980:	5f 91       	pop	r21
 982:	4f 91       	pop	r20
 984:	3f 91       	pop	r19
 986:	2f 91       	pop	r18
 988:	0f 90       	pop	r0
 98a:	0f be       	out	0x3f, r0	; 63
 98c:	0f 90       	pop	r0
 98e:	1f 90       	pop	r1
 990:	18 95       	reti

00000992 <__vector_50>:
 *
 * This function will handle interrupt on Timer Counter E0 Compare/CaptureB and
 * call the callback function.
 */
ISR(TCE0_CCB_vect)
{
 992:	1f 92       	push	r1
 994:	0f 92       	push	r0
 996:	0f b6       	in	r0, 0x3f	; 63
 998:	0f 92       	push	r0
 99a:	11 24       	eor	r1, r1
 99c:	2f 93       	push	r18
 99e:	3f 93       	push	r19
 9a0:	4f 93       	push	r20
 9a2:	5f 93       	push	r21
 9a4:	6f 93       	push	r22
 9a6:	7f 93       	push	r23
 9a8:	8f 93       	push	r24
 9aa:	9f 93       	push	r25
 9ac:	af 93       	push	r26
 9ae:	bf 93       	push	r27
 9b0:	ef 93       	push	r30
 9b2:	ff 93       	push	r31
	if (tc_tce0_ccb_callback) {
 9b4:	e0 91 3a 20 	lds	r30, 0x203A	; 0x80203a <tc_tce0_ccb_callback>
 9b8:	f0 91 3b 20 	lds	r31, 0x203B	; 0x80203b <tc_tce0_ccb_callback+0x1>
 9bc:	30 97       	sbiw	r30, 0x00	; 0
 9be:	09 f0       	breq	.+2      	; 0x9c2 <__vector_50+0x30>
		tc_tce0_ccb_callback();
 9c0:	09 95       	icall
	}
}
 9c2:	ff 91       	pop	r31
 9c4:	ef 91       	pop	r30
 9c6:	bf 91       	pop	r27
 9c8:	af 91       	pop	r26
 9ca:	9f 91       	pop	r25
 9cc:	8f 91       	pop	r24
 9ce:	7f 91       	pop	r23
 9d0:	6f 91       	pop	r22
 9d2:	5f 91       	pop	r21
 9d4:	4f 91       	pop	r20
 9d6:	3f 91       	pop	r19
 9d8:	2f 91       	pop	r18
 9da:	0f 90       	pop	r0
 9dc:	0f be       	out	0x3f, r0	; 63
 9de:	0f 90       	pop	r0
 9e0:	1f 90       	pop	r1
 9e2:	18 95       	reti

000009e4 <__vector_51>:
 *
 * This function will handle interrupt on Timer Counter E0 Compare/CaptureC and
 * call the callback function.
 */
ISR(TCE0_CCC_vect)
{
 9e4:	1f 92       	push	r1
 9e6:	0f 92       	push	r0
 9e8:	0f b6       	in	r0, 0x3f	; 63
 9ea:	0f 92       	push	r0
 9ec:	11 24       	eor	r1, r1
 9ee:	2f 93       	push	r18
 9f0:	3f 93       	push	r19
 9f2:	4f 93       	push	r20
 9f4:	5f 93       	push	r21
 9f6:	6f 93       	push	r22
 9f8:	7f 93       	push	r23
 9fa:	8f 93       	push	r24
 9fc:	9f 93       	push	r25
 9fe:	af 93       	push	r26
 a00:	bf 93       	push	r27
 a02:	ef 93       	push	r30
 a04:	ff 93       	push	r31
	if (tc_tce0_ccc_callback) {
 a06:	e0 91 38 20 	lds	r30, 0x2038	; 0x802038 <tc_tce0_ccc_callback>
 a0a:	f0 91 39 20 	lds	r31, 0x2039	; 0x802039 <tc_tce0_ccc_callback+0x1>
 a0e:	30 97       	sbiw	r30, 0x00	; 0
 a10:	09 f0       	breq	.+2      	; 0xa14 <__vector_51+0x30>
		tc_tce0_ccc_callback();
 a12:	09 95       	icall
	}
}
 a14:	ff 91       	pop	r31
 a16:	ef 91       	pop	r30
 a18:	bf 91       	pop	r27
 a1a:	af 91       	pop	r26
 a1c:	9f 91       	pop	r25
 a1e:	8f 91       	pop	r24
 a20:	7f 91       	pop	r23
 a22:	6f 91       	pop	r22
 a24:	5f 91       	pop	r21
 a26:	4f 91       	pop	r20
 a28:	3f 91       	pop	r19
 a2a:	2f 91       	pop	r18
 a2c:	0f 90       	pop	r0
 a2e:	0f be       	out	0x3f, r0	; 63
 a30:	0f 90       	pop	r0
 a32:	1f 90       	pop	r1
 a34:	18 95       	reti

00000a36 <__vector_52>:
 *
 * This function will handle interrupt on Timer Counter E0 Compare/CaptureD and
 * call the callback function.
 */
ISR(TCE0_CCD_vect)
{
 a36:	1f 92       	push	r1
 a38:	0f 92       	push	r0
 a3a:	0f b6       	in	r0, 0x3f	; 63
 a3c:	0f 92       	push	r0
 a3e:	11 24       	eor	r1, r1
 a40:	2f 93       	push	r18
 a42:	3f 93       	push	r19
 a44:	4f 93       	push	r20
 a46:	5f 93       	push	r21
 a48:	6f 93       	push	r22
 a4a:	7f 93       	push	r23
 a4c:	8f 93       	push	r24
 a4e:	9f 93       	push	r25
 a50:	af 93       	push	r26
 a52:	bf 93       	push	r27
 a54:	ef 93       	push	r30
 a56:	ff 93       	push	r31
	if (tc_tce0_ccd_callback) {
 a58:	e0 91 36 20 	lds	r30, 0x2036	; 0x802036 <__data_end>
 a5c:	f0 91 37 20 	lds	r31, 0x2037	; 0x802037 <__data_end+0x1>
 a60:	30 97       	sbiw	r30, 0x00	; 0
 a62:	09 f0       	breq	.+2      	; 0xa66 <__vector_52+0x30>
		tc_tce0_ccd_callback();
 a64:	09 95       	icall
	}
}
 a66:	ff 91       	pop	r31
 a68:	ef 91       	pop	r30
 a6a:	bf 91       	pop	r27
 a6c:	af 91       	pop	r26
 a6e:	9f 91       	pop	r25
 a70:	8f 91       	pop	r24
 a72:	7f 91       	pop	r23
 a74:	6f 91       	pop	r22
 a76:	5f 91       	pop	r21
 a78:	4f 91       	pop	r20
 a7a:	3f 91       	pop	r19
 a7c:	2f 91       	pop	r18
 a7e:	0f 90       	pop	r0
 a80:	0f be       	out	0x3f, r0	; 63
 a82:	0f 90       	pop	r0
 a84:	1f 90       	pop	r1
 a86:	18 95       	reti

00000a88 <resetPosition>:
void putChar(uint8_t chr)
{
	while(!(USARTE0.STATUS & USART_DREIF_bm));
	USARTE0.DATA = chr;
	while(!(USARTE0.STATUS & USART_DREIF_bm));
	USARTE0.DATA = '\n';
 a88:	80 e0       	ldi	r24, 0x00	; 0
 a8a:	90 e1       	ldi	r25, 0x10	; 16
 a8c:	80 93 60 09 	sts	0x0960, r24	; 0x800960 <__TEXT_REGION_LENGTH__+0x700960>
 a90:	90 93 61 09 	sts	0x0961, r25	; 0x800961 <__TEXT_REGION_LENGTH__+0x700961>
 a94:	80 93 60 08 	sts	0x0860, r24	; 0x800860 <__TEXT_REGION_LENGTH__+0x700860>
 a98:	90 93 61 08 	sts	0x0861, r25	; 0x800861 <__TEXT_REGION_LENGTH__+0x700861>
 a9c:	80 93 20 09 	sts	0x0920, r24	; 0x800920 <__TEXT_REGION_LENGTH__+0x700920>
 aa0:	90 93 21 09 	sts	0x0921, r25	; 0x800921 <__TEXT_REGION_LENGTH__+0x700921>
 aa4:	08 95       	ret

00000aa6 <initProximalQdec>:
 aa6:	e0 e4       	ldi	r30, 0x40	; 64
 aa8:	f6 e0       	ldi	r31, 0x06	; 6
 aaa:	8c e0       	ldi	r24, 0x0C	; 12
 aac:	82 83       	std	Z+2, r24	; 0x02
 aae:	80 e4       	ldi	r24, 0x40	; 64
 ab0:	81 8b       	std	Z+17, r24	; 0x11
 ab2:	8b e1       	ldi	r24, 0x1B	; 27
 ab4:	82 8b       	std	Z+18, r24	; 0x12
 ab6:	83 8b       	std	Z+19, r24	; 0x13
 ab8:	e0 e8       	ldi	r30, 0x80	; 128
 aba:	f1 e0       	ldi	r31, 0x01	; 1
 abc:	82 e6       	ldi	r24, 0x62	; 98
 abe:	80 83       	st	Z, r24
 ac0:	89 e0       	ldi	r24, 0x09	; 9
 ac2:	80 87       	std	Z+8, r24	; 0x08
 ac4:	e0 e4       	ldi	r30, 0x40	; 64
 ac6:	f8 e0       	ldi	r31, 0x08	; 8
 ac8:	88 e6       	ldi	r24, 0x68	; 104
 aca:	83 83       	std	Z+3, r24	; 0x03
 acc:	80 e0       	ldi	r24, 0x00	; 0
 ace:	90 e2       	ldi	r25, 0x20	; 32
 ad0:	86 a3       	std	Z+38, r24	; 0x26
 ad2:	97 a3       	std	Z+39, r25	; 0x27
 ad4:	81 e0       	ldi	r24, 0x01	; 1
 ad6:	80 83       	st	Z, r24
 ad8:	80 e0       	ldi	r24, 0x00	; 0
 ada:	90 e1       	ldi	r25, 0x10	; 16
 adc:	80 a3       	std	Z+32, r24	; 0x20
 ade:	91 a3       	std	Z+33, r25	; 0x21
 ae0:	08 95       	ret

00000ae2 <initMedialQdec>:
 ae2:	e0 e6       	ldi	r30, 0x60	; 96
 ae4:	f6 e0       	ldi	r31, 0x06	; 6
 ae6:	8c e0       	ldi	r24, 0x0C	; 12
 ae8:	82 83       	std	Z+2, r24	; 0x02
 aea:	80 e4       	ldi	r24, 0x40	; 64
 aec:	81 8b       	std	Z+17, r24	; 0x11
 aee:	8b e1       	ldi	r24, 0x1B	; 27
 af0:	82 8b       	std	Z+18, r24	; 0x12
 af2:	83 8b       	std	Z+19, r24	; 0x13
 af4:	e0 e8       	ldi	r30, 0x80	; 128
 af6:	f1 e0       	ldi	r31, 0x01	; 1
 af8:	8a e6       	ldi	r24, 0x6A	; 106
 afa:	82 83       	std	Z+2, r24	; 0x02
 afc:	99 e0       	ldi	r25, 0x09	; 9
 afe:	92 87       	std	Z+10, r25	; 0x0a
 b00:	e0 e0       	ldi	r30, 0x00	; 0
 b02:	f9 e0       	ldi	r31, 0x09	; 9
 b04:	83 83       	std	Z+3, r24	; 0x03
 b06:	80 e0       	ldi	r24, 0x00	; 0
 b08:	90 e2       	ldi	r25, 0x20	; 32
 b0a:	86 a3       	std	Z+38, r24	; 0x26
 b0c:	97 a3       	std	Z+39, r25	; 0x27
 b0e:	81 e0       	ldi	r24, 0x01	; 1
 b10:	80 83       	st	Z, r24
 b12:	80 e0       	ldi	r24, 0x00	; 0
 b14:	90 e1       	ldi	r25, 0x10	; 16
 b16:	80 a3       	std	Z+32, r24	; 0x20
 b18:	91 a3       	std	Z+33, r25	; 0x21
 b1a:	08 95       	ret

00000b1c <initDistalQdec>:
 b1c:	e0 e0       	ldi	r30, 0x00	; 0
 b1e:	f6 e0       	ldi	r31, 0x06	; 6
 b20:	8c e0       	ldi	r24, 0x0C	; 12
 b22:	82 83       	std	Z+2, r24	; 0x02
 b24:	80 e4       	ldi	r24, 0x40	; 64
 b26:	81 8b       	std	Z+17, r24	; 0x11
 b28:	8b e1       	ldi	r24, 0x1B	; 27
 b2a:	82 8b       	std	Z+18, r24	; 0x12
 b2c:	83 8b       	std	Z+19, r24	; 0x13
 b2e:	e0 e8       	ldi	r30, 0x80	; 128
 b30:	f1 e0       	ldi	r31, 0x01	; 1
 b32:	82 e5       	ldi	r24, 0x52	; 82
 b34:	84 83       	std	Z+4, r24	; 0x04
 b36:	89 e0       	ldi	r24, 0x09	; 9
 b38:	84 87       	std	Z+12, r24	; 0x0c
 b3a:	e0 e4       	ldi	r30, 0x40	; 64
 b3c:	f9 e0       	ldi	r31, 0x09	; 9
 b3e:	8c e6       	ldi	r24, 0x6C	; 108
 b40:	83 83       	std	Z+3, r24	; 0x03
 b42:	80 e0       	ldi	r24, 0x00	; 0
 b44:	90 e2       	ldi	r25, 0x20	; 32
 b46:	86 a3       	std	Z+38, r24	; 0x26
 b48:	97 a3       	std	Z+39, r25	; 0x27
 b4a:	81 e0       	ldi	r24, 0x01	; 1
 b4c:	80 83       	st	Z, r24
 b4e:	80 e0       	ldi	r24, 0x00	; 0
 b50:	90 e1       	ldi	r25, 0x10	; 16
 b52:	80 a3       	std	Z+32, r24	; 0x20
 b54:	91 a3       	std	Z+33, r25	; 0x21
 b56:	08 95       	ret

00000b58 <initLed>:
 b58:	e0 e0       	ldi	r30, 0x00	; 0
 b5a:	f6 e0       	ldi	r31, 0x06	; 6
 b5c:	80 81       	ld	r24, Z
 b5e:	80 68       	ori	r24, 0x80	; 128
 b60:	80 83       	st	Z, r24
 b62:	84 81       	ldd	r24, Z+4	; 0x04
 b64:	14 82       	std	Z+4, r1	; 0x04
 b66:	08 95       	ret

00000b68 <initUart>:
 b68:	e0 ea       	ldi	r30, 0xA0	; 160
 b6a:	fa e0       	ldi	r31, 0x0A	; 10
 b6c:	80 eb       	ldi	r24, 0xB0	; 176
 b6e:	86 83       	std	Z+6, r24	; 0x06
 b70:	17 82       	std	Z+7, r1	; 0x07
 b72:	87 81       	ldd	r24, Z+7	; 0x07
 b74:	80 6b       	ori	r24, 0xB0	; 176
 b76:	87 83       	std	Z+7, r24	; 0x07
 b78:	80 e1       	ldi	r24, 0x10	; 16
 b7a:	83 83       	std	Z+3, r24	; 0x03
 b7c:	81 81       	ldd	r24, Z+1	; 0x01
 b7e:	80 68       	ori	r24, 0x80	; 128
 b80:	81 83       	std	Z+1, r24	; 0x01
 b82:	88 e1       	ldi	r24, 0x18	; 24
 b84:	84 83       	std	Z+4, r24	; 0x04
 b86:	83 e0       	ldi	r24, 0x03	; 3
 b88:	85 83       	std	Z+5, r24	; 0x05
 b8a:	85 81       	ldd	r24, Z+5	; 0x05
 b8c:	87 7c       	andi	r24, 0xC7	; 199
 b8e:	85 83       	std	Z+5, r24	; 0x05
 b90:	88 e0       	ldi	r24, 0x08	; 8
 b92:	80 93 80 06 	sts	0x0680, r24	; 0x800680 <__TEXT_REGION_LENGTH__+0x700680>
 b96:	81 81       	ldd	r24, Z+1	; 0x01
 b98:	85 ff       	sbrs	r24, 5
 b9a:	fd cf       	rjmp	.-6      	; 0xb96 <initUart+0x2e>
 b9c:	81 e0       	ldi	r24, 0x01	; 1
 b9e:	80 93 a2 00 	sts	0x00A2, r24	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
 ba2:	78 94       	sei
 ba4:	08 95       	ret

00000ba6 <main>:
 ba6:	78 94       	sei
 ba8:	d7 df       	rcall	.-82     	; 0xb58 <initLed>
 baa:	de df       	rcall	.-68     	; 0xb68 <initUart>
 bac:	7c df       	rcall	.-264    	; 0xaa6 <initProximalQdec>
 bae:	99 df       	rcall	.-206    	; 0xae2 <initMedialQdec>
 bb0:	b5 df       	rcall	.-150    	; 0xb1c <initDistalQdec>
 bb2:	ff cf       	rjmp	.-2      	; 0xbb2 <main+0xc>

00000bb4 <sendMsg>:
 bb4:	fc 01       	movw	r30, r24
 bb6:	20 81       	ld	r18, Z
 bb8:	22 23       	and	r18, r18
 bba:	59 f0       	breq	.+22     	; 0xbd2 <sendMsg+0x1e>
 bbc:	dc 01       	movw	r26, r24
 bbe:	11 96       	adiw	r26, 0x01	; 1
 bc0:	e0 ea       	ldi	r30, 0xA0	; 160
 bc2:	fa e0       	ldi	r31, 0x0A	; 10
 bc4:	91 81       	ldd	r25, Z+1	; 0x01
 bc6:	95 ff       	sbrs	r25, 5
 bc8:	fd cf       	rjmp	.-6      	; 0xbc4 <sendMsg+0x10>
 bca:	20 83       	st	Z, r18
 bcc:	2d 91       	ld	r18, X+
 bce:	21 11       	cpse	r18, r1
 bd0:	f9 cf       	rjmp	.-14     	; 0xbc4 <sendMsg+0x10>
 bd2:	08 95       	ret

00000bd4 <sendByte>:
}

void sendByte(uint8_t data) 
{
	while(!(USARTE0.STATUS & USART_DREIF_bm));
 bd4:	e0 ea       	ldi	r30, 0xA0	; 160
 bd6:	fa e0       	ldi	r31, 0x0A	; 10
 bd8:	91 81       	ldd	r25, Z+1	; 0x01
 bda:	95 ff       	sbrs	r25, 5
 bdc:	fd cf       	rjmp	.-6      	; 0xbd8 <sendByte+0x4>
	USARTE0.DATA = data;
 bde:	80 93 a0 0a 	sts	0x0AA0, r24	; 0x800aa0 <__TEXT_REGION_LENGTH__+0x700aa0>
 be2:	08 95       	ret

00000be4 <sendEscByte>:
}

void sendEscByte(uint8_t data) 
{
 be4:	cf 93       	push	r28
 be6:	c8 2f       	mov	r28, r24
	if (data == START_BYTE || data == END_BYTE || data == ESCAPE_BYTE) 
 be8:	8a 3a       	cpi	r24, 0xAA	; 170
 bea:	21 f0       	breq	.+8      	; 0xbf4 <sendEscByte+0x10>
 bec:	8b 3b       	cpi	r24, 0xBB	; 187
 bee:	11 f0       	breq	.+4      	; 0xbf4 <sendEscByte+0x10>
 bf0:	8d 37       	cpi	r24, 0x7D	; 125
 bf2:	31 f4       	brne	.+12     	; 0xc00 <sendEscByte+0x1c>
	{
		// send escape byte
		sendByte(ESCAPE_BYTE);
 bf4:	8d e7       	ldi	r24, 0x7D	; 125
 bf6:	ee df       	rcall	.-36     	; 0xbd4 <sendByte>
		// send xored data
		sendByte(data ^ 0x20);
 bf8:	80 e2       	ldi	r24, 0x20	; 32
 bfa:	8c 27       	eor	r24, r28
 bfc:	eb df       	rcall	.-42     	; 0xbd4 <sendByte>
	} 
	else 
	{
		sendByte(data);
 bfe:	01 c0       	rjmp	.+2      	; 0xc02 <sendEscByte+0x1e>
 c00:	e9 df       	rcall	.-46     	; 0xbd4 <sendByte>
	}
}
 c02:	cf 91       	pop	r28
 c04:	08 95       	ret

00000c06 <sendData>:

void sendData(uint16_t num1, uint16_t num2, uint16_t num3) 
{
 c06:	ef 92       	push	r14
 c08:	ff 92       	push	r15
 c0a:	0f 93       	push	r16
 c0c:	1f 93       	push	r17
 c0e:	cf 93       	push	r28
 c10:	df 93       	push	r29
 c12:	f8 2e       	mov	r15, r24
 c14:	e9 2e       	mov	r14, r25
 c16:	16 2f       	mov	r17, r22
 c18:	07 2f       	mov	r16, r23
 c1a:	c4 2f       	mov	r28, r20
 c1c:	d5 2f       	mov	r29, r21
	sendByte(START_BYTE);
 c1e:	8a ea       	ldi	r24, 0xAA	; 170
 c20:	d9 df       	rcall	.-78     	; 0xbd4 <sendByte>
	sendEscByte((uint8_t)(num1 >> 8));   // high byte
 c22:	8e 2d       	mov	r24, r14
 c24:	df df       	rcall	.-66     	; 0xbe4 <sendEscByte>
	sendEscByte((uint8_t)(num1 & 0xFF)); // low byte 
 c26:	8f 2d       	mov	r24, r15
 c28:	dd df       	rcall	.-70     	; 0xbe4 <sendEscByte>
	sendEscByte((uint8_t)(num2 >> 8));   // high byte
 c2a:	80 2f       	mov	r24, r16
 c2c:	db df       	rcall	.-74     	; 0xbe4 <sendEscByte>
	sendEscByte((uint8_t)(num2 & 0xFF)); // low byte 
 c2e:	81 2f       	mov	r24, r17
 c30:	d9 df       	rcall	.-78     	; 0xbe4 <sendEscByte>
	sendEscByte((uint8_t)(num3 >> 8));   // high byte
 c32:	8d 2f       	mov	r24, r29
 c34:	d7 df       	rcall	.-82     	; 0xbe4 <sendEscByte>
	sendEscByte((uint8_t)(num3 & 0xFF)); // low byte 
 c36:	8c 2f       	mov	r24, r28
 c38:	d5 df       	rcall	.-86     	; 0xbe4 <sendEscByte>
 c3a:	8b eb       	ldi	r24, 0xBB	; 187
	sendByte(END_BYTE);
 c3c:	cb df       	rcall	.-106    	; 0xbd4 <sendByte>
 c3e:	df 91       	pop	r29
 c40:	cf 91       	pop	r28
}
 c42:	1f 91       	pop	r17
 c44:	0f 91       	pop	r16
 c46:	ff 90       	pop	r15
 c48:	ef 90       	pop	r14
 c4a:	08 95       	ret

00000c4c <__vector_58>:
 c4c:	1f 92       	push	r1
 c4e:	0f 92       	push	r0
void sendEscByte(uint8_t data);
void sendData(uint16_t num1, uint16_t num2, uint16_t num3);

// handle usb request
ISR(USARTE0_RXC_vect)
{
 c50:	0f b6       	in	r0, 0x3f	; 63
 c52:	0f 92       	push	r0
 c54:	11 24       	eor	r1, r1
 c56:	2f 93       	push	r18
 c58:	3f 93       	push	r19
 c5a:	4f 93       	push	r20
 c5c:	5f 93       	push	r21
 c5e:	6f 93       	push	r22
 c60:	7f 93       	push	r23
 c62:	8f 93       	push	r24
 c64:	9f 93       	push	r25
 c66:	af 93       	push	r26
 c68:	bf 93       	push	r27
 c6a:	ef 93       	push	r30
 c6c:	ff 93       	push	r31
	// LED on
	PORTA.OUT |= (1 << 7);
 c6e:	e0 e0       	ldi	r30, 0x00	; 0
 c70:	f6 e0       	ldi	r31, 0x06	; 6
 c72:	84 81       	ldd	r24, Z+4	; 0x04
 c74:	80 68       	ori	r24, 0x80	; 128
 c76:	84 83       	std	Z+4, r24	; 0x04
	uint8_t data = USARTE0.DATA;
 c78:	80 91 a0 0a 	lds	r24, 0x0AA0	; 0x800aa0 <__TEXT_REGION_LENGTH__+0x700aa0>
	if (data == START_BYTE) 
 c7c:	8a 3a       	cpi	r24, 0xAA	; 170
 c7e:	71 f4       	brne	.+28     	; 0xc9c <__vector_58+0x50>
		// prox_pos, med_pos, dist_pos
		sendData(TCC1.CNT, TCD0.CNT, TCD1.CNT);
 c80:	40 91 60 09 	lds	r20, 0x0960	; 0x800960 <__TEXT_REGION_LENGTH__+0x700960>
 c84:	50 91 61 09 	lds	r21, 0x0961	; 0x800961 <__TEXT_REGION_LENGTH__+0x700961>
 c88:	60 91 20 09 	lds	r22, 0x0920	; 0x800920 <__TEXT_REGION_LENGTH__+0x700920>
 c8c:	70 91 21 09 	lds	r23, 0x0921	; 0x800921 <__TEXT_REGION_LENGTH__+0x700921>
 c90:	80 91 60 08 	lds	r24, 0x0860	; 0x800860 <__TEXT_REGION_LENGTH__+0x700860>
 c94:	90 91 61 08 	lds	r25, 0x0861	; 0x800861 <__TEXT_REGION_LENGTH__+0x700861>
 c98:	b6 df       	rcall	.-148    	; 0xc06 <sendData>
 c9a:	07 c0       	rjmp	.+14     	; 0xcaa <__vector_58+0x5e>
	else if (data == END_BYTE)
 c9c:	8b 3b       	cpi	r24, 0xBB	; 187
		resetPosition();
 c9e:	11 f4       	brne	.+4      	; 0xca4 <__vector_58+0x58>
 ca0:	f3 de       	rcall	.-538    	; 0xa88 <resetPosition>
 ca2:	03 c0       	rjmp	.+6      	; 0xcaa <__vector_58+0x5e>
	else
		sendMsg("Send 0xBB for counter reset, 0xAA for position query\n");
 ca4:	80 e0       	ldi	r24, 0x00	; 0
 ca6:	90 e2       	ldi	r25, 0x20	; 32
 ca8:	85 df       	rcall	.-246    	; 0xbb4 <sendMsg>
	// LED off
	PORTA.OUT &= (0 << 7);
 caa:	e0 e0       	ldi	r30, 0x00	; 0
 cac:	f6 e0       	ldi	r31, 0x06	; 6
 cae:	84 81       	ldd	r24, Z+4	; 0x04
 cb0:	14 82       	std	Z+4, r1	; 0x04
}
 cb2:	ff 91       	pop	r31
 cb4:	ef 91       	pop	r30
 cb6:	bf 91       	pop	r27
 cb8:	af 91       	pop	r26
 cba:	9f 91       	pop	r25
 cbc:	8f 91       	pop	r24
 cbe:	7f 91       	pop	r23
 cc0:	6f 91       	pop	r22
 cc2:	5f 91       	pop	r21
 cc4:	4f 91       	pop	r20
 cc6:	3f 91       	pop	r19
 cc8:	2f 91       	pop	r18
 cca:	0f 90       	pop	r0
 ccc:	0f be       	out	0x3f, r0	; 63
 cce:	0f 90       	pop	r0
 cd0:	1f 90       	pop	r1
 cd2:	18 95       	reti

00000cd4 <_exit>:
 cd4:	f8 94       	cli

00000cd6 <__stop_program>:
 cd6:	ff cf       	rjmp	.-2      	; 0xcd6 <__stop_program>
